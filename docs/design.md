---
layout: page
title: Design
permalink: /design/
---
# MCU Design

# FPGA Design
#### Display Stages
The FPGA's main funtionality revolves around displaying the timer and other states of the system throughout the user's interaction.  During the user's interact, the display will increment when starting, decrement during the movement stage, and flash at the end.  This is accomplished through state logic demonstrated in the figure below.

<div style="text-align: left">
  <img src="./assets/schematics/game_timing.png" alt="game" width="100" />
</div>

As shown in the figure, we can see that we have a variable, TIM, that increments after the user begins.  TIM increments based on a slow clock generated by dividing down the onboard 48 MHz HOSC to around 2.8 Hz.  This provides the user with sufficient time to perform each of the duties and allocates a reasonable starting time.

Initially, the team planned on displaying numbers as a countdown, but after signfiicant testing, the team decided the given LED matrix did not have full functionality. However despite issues with the display, the team was able to set the timer to be a decrementing "tank" as time passed by turning off rows of the display. Inversely, the team could increment the "tank" as an initializing sequence and also flash it upon completion.  This functionality will be discussed further in the next section. 

<div style="text-align: left">
  <img src="./assets/img/led_mat_half.jpg" alt="schem" width="100" />
</div>

#### Display Hardware Design
The display itself is not straightforward to interface with, but a previous Microps final project revolved around creating custom pictures on it.  In 2019, Reem Alkhamis and Sabrine Griffith's project "LED Visual Art" displayed images on the display that would alter depending on input from a IMU.  Since our project was not primarily focused on the display, we were able to leverage their setup to begin our work.  A big thanks to them both for providing us with a great starting point.  A big hint to the LED display lacking full functionality was their project not functioning properly.

The 32x32 LED display works by setting the RGB value of each LED in each 32 LED row through multiplexing and a 192 bit shift register.  The 192 bit shift register contains the RGB values of 2 whole rows.  Then, through a row control input, you select the two rows that display the values.  With a fast enough clock, this is seemless and there is not bleeding.  There are additional signals that accompany the control signals such as a output enable and latch.  These signals control the transition from one row to the next as time passes.

The issue we encountered with the display was the inconsistent display of RGB values.  The previous project utilizted RAM to store and access the necessary RGB data, and when we tried to incorporate their design, it did not consistently function.  However, we were able to get the LED matrix to fully turn on.  From there, we could control which rows were getting outputted so we would have an incrementing, decrementing, or flashing display.  

As noted above, these stages were each controlled by both the TIM variable as well as the button press.  The TIM variable would increment with the slow clock and with the use of assign statements in the top level module along with some booleans, we can manipulate the signal even further to being slow. The decrementing is much slower than the incrementing because the columns only decrement every fourth clock signal when the timer is in the select range. Additionally, the flashing is achieved by inverting the maximum row value at each clock cycle from 0 to 16.  

Lastly, as noted above, the FPGA is only controlled via a single bit enable line from the MCU.  The enable line is asserted upon the first button push and deasserted on the second.  If never deasserted, the FPGA timer will reach a maximum value, and perform the final flash automatically. This does not need to be sent over to the MCU because the clocks are synchronized to a significant resolution.

# Mechanical Design
